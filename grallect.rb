#!/usr/bin/env ruby


require 'json'
require 'logger'
require 'open-uri'
require 'pp'
require 'uri'

class Grallect

  def initialize(host)
    # this should be generated by merging together defaults and a configuration file
    @config = { 
      :graphite => { :url => 'http://localhost' },
      :collectd => { :prefix => nil, :postfix => '.collectd', :escape_character => '_', :interval => 10 },
      :cpu => { :warning => 80, :critical => 95 },
      :memory => { :warning => 80, :critical => 95 },
      :interface => { :speed => 1000, :warning => 80, :critical => 95 },
      :disk => { :iops => 100, :warning => 80, :critical => 95 },
      :window => 60,
      :verbose => true,
    }

    escaped_host = host.gsub!('.', @config[:collectd][:escape_character])
    @host_path = "#{@config[:collectd][:prefix]}#{escaped_host}#{@config[:collectd][:postfix]}"

    @logger = Logger.new(STDERR)
    @logger.level = @config[:verbose] ? Logger::DEBUG : Logger::ERROR
  end

  def get_data(graphite_expression)
    # number of data points to average together
    samples = @config[:window] / @config[:collectd][:interval]

    url = URI.escape("#{@config[:graphite][:url]}/render/?format=json&target=movingAverage(#{graphite_expression},#{samples})&from=-#{@config[:window]}seconds")
    @logger.debug URI.unescape(url)

    begin
      response = open(url).read
      @logger.debug response
    rescue SocketError => e
      @logger.fatal e.message
      exit 1
    end

    begin
      data = JSON.parse(response)
    rescue ParserError => e
      @logger.fatal e.message
      exit 1
    end

    return data
  end

  def output_status(code, results)
    case code
    when 0
      output = 'OK: '
    when 1
      output = 'WARNING: '
    when 2
      output = 'CRITICAL: '
    else
      output = 'UNKNOWN: No data was found'
    end

    results.each { |r| output = output + "#{r[:label]} was #{r[:value]}. " }

    puts output
    exit code
  end

  def update_code(code, value, warning, critical)
    case code
    when 3
      return 3
    when 2
      return 2
    when 1
      if value >= critical
        return 2
      else
        return 1
      end
    else
      if value >= warning and value <= critical
        return 1
      elsif value >= critical
        return 2
      else
        return 0
      end
    end
  end

  def check_cpu
    results = []
    code = nil

    # fetching user and system seperately makes handling the results easier
    user_data = self.get_data("#{@host_path}.cpu-*.cpu-user")
    system_data = self.get_data("#{@host_path}.cpu-*.cpu-system")

    user_values = user_data.map { |d| d['datapoints'].last.first }
    system_values = system_data.map { |d| d['datapoints'].last.first }

    # add user and system data together for the check
    values = [user_values, system_values].transpose.map { |a| a.reduce(:+) }

    if values.empty?
      @logger.warn "No data found"
      code = 3
    else
      values.each_with_index do |value, i|
        code = update_code(code, value, @config[:cpu][:warning], @config[:cpu][:critical])
        results.push({:label => "CPU #{i} usage percentage", :value => value})
      end
    end

    output_status(code, results)
  end

  def check_disk
    results = []
    code = nil

    # fetch in similar style to cpu
    # have graphite turn raw iops into percentage for me
    read_data = self.get_data("asPercent(#{@host_path}.disk-sd*.disk_ops.read,#{@config[:disk][:iops]})")
    write_data = self.get_data("asPercent(#{@host_path}.disk-sd*.disk_ops.write,#{@config[:disk][:iops]})")

    read_values = read_data.map { |d| d['datapoints'].last.first }
    write_values = write_data.map { |d| d['datapoints'].last.first }

    labels = read_data.map { |d| /disk-(.*?)\./.match(d['target'])[1] }
    values = [read_values, write_values].transpose.map { |a| a.reduce(:+) }
    data = Hash[labels.zip(values)]

    if data.empty?
      @logger.warn "No data found"
      code = 3
    else
      data.each_key do |k|
        code = update_code(code, data[k], @config[:disk][:warning], @config[:disk][:critical])
        results.push( {:label => "Disk #{k} activity percentage", :value => data[k]} )
      end
    end

    output_status(code, results)
  end

  def check_interface
    results = []
    code = nil

    # fetch both tx and rx at once
    # checking them seperatly instead of combining
    data = self.get_data("#{@host_path}.interface-*.if_octets.*")

    if data.empty?
      @logger.warn "No data found"
      code = 3
    else
      data.each do |d|
        interface = /interface-(.*?)\./.match(d['target'])[1]
        direction = /if_octets\.(.*),/.match(d['target'])[1]
        # convert bytes to megabits
        value = d['datapoints'].last.first / 131072
        code = update_code(code, value, @config[:interface][:warning], @config[:interface][:critical])
        results.push({:label => "Interface #{interface} #{direction} transferred", :value => value})
      end
    end

    output_status(code, results)
  end

  def check_memory
    results = []
    code = nil

    # this fetches memory used as percentage of total memory
    # and memory free as percetage of total memory
    # we only check the former
    data = self.get_data("asPercent(#{@host_path}.memory.memory-{used,free})")

    if data.empty?
      @logger.warn "No data found"
      code = 3
    else
      value = data.first['datapoints'].last.first
      code = update_code(code, value, @config[:memory][:warning], @config[:memory][:critical])
      results.push({:label => "Memory usage percentage", :value => value})
    end

    output_status(code, results)
  end
end

# this should be generated by command line arguments
command = ARGV[0]
host = 'example.com'

g = Grallect.new(host)

case command
when 'cpu'
  g.check_cpu
when 'disk'
  g.check_disk
when 'memory'
  g.check_memory
when 'interface'
  g.check_interface
else
  puts 'What kind of command is that?'
end
